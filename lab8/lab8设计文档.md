# lab8设计文档
## CSS
用js在样式单的最后添加了一些规则。

遇到了一点兼容性问题，Chrome对cssRules属性的支持有问题。对于\<link\>元素相应的StyleSheet，用file协议打开html文件时，访问它的cssRules属性会报错：`Failed to read the 'cssRules' property from 'CSSStyleSheet': Cannot access rules`。用rules属性也是一样。

但是，用PhpStorm提供的localhost打开html文件，就没有这个问题。此时看到加入的css规则在调试界面显示为一个像user agent stylesheet一样的不可编辑的规则，显示的来源是\<style\>。注意到链接被切断后的外部css也会有类似的显示。另外，我碰巧写了一条`background-color: lightgray`，在调试界面看到的却是`background-color: lightgrey`。因此猜测，PhpStorm对于Chrome的这个问题可能提供了补丁，它把整个css文件先处理了一遍。

但是要求是双击打开html文件，所以还是要另想办法。我只是添加了一些规则，并不需要修改或删除，所以其实直接添加一个\<style\>元素反而会更加方便。用outerHTML的方式把整个元素写出来，这样还可以获得IDE给css提供的各种提示和颜色标记。
## 轮播
任务一和任务三共用相同的主要代码。

轮播图片支持动画切换，在固定的时间内，图片条从起始图片匀速滑动至目标图片，动画结束后更新数字标记。用户可以在动画期间继续点击左右箭头或数字按钮。

因为同一时间最多只能有一个图片切换动画，所以写了全局唯一的transition函数对象。切换时间设为DURATION。如果用户连续点击按钮，那么动画会重置，图片总是会在最后一次点击之后经过DURATION时间从当前位置滑动到最后目标位置，然后更新数字标记。

我本来设想的实现方式是所有图片都叠放在轮播区域内，除了当前显示的图片以外，其他都`display: none`。当点击左右箭头切换图片时，把目标图片移出来，补在原始图片旁边，然后开始滑动。按照这样的思路，我先修改css到只剩一张图片，此时看到轮播区域内是空白，检查了代码，也试了z-index，就是想不明白我到底写了什么bug。后来在调试界面看到图片本来是水平流式摆放的，才知道这里的轮播是实现为图片带的滑动。

用margin-left设定图片位置。当有多张图片要放在屏幕左边界以外时，负边距不会自动设定，需要为每一张图片设置边距。边距为正可以自动设置，这时可以删除margin-left属性。
## 自动播放
倒计时也是全局唯一的，用timer函数对象实现。页面完全加载后开始计时。

后台时间线运行不稳定。停在当前页面或者切换到系统的其他进程，轮播都可以正常运行。但是切换到同一个浏览器的其他窗口，时间线上的代码就很不准时，结果造成数字标记丢失，控制台反复报错。为了解决这个问题，我增加了一个逻辑，窗口失去焦点时停止计时，获得焦点时再开始计时，并且已经在计时的状态下就不允许重复开始计时。

浏览器也确实应该这样处理后台代码。后台持续占用CPU是非常用户不友好的行为，而且JS是单线程语言，有限的资源必须优先分配给前台页面。所以没有焦点的状态下暂停轮播比较合适。

这样做可以保证正常查看页面的过程中自动轮播不出bug，但是问题本身没有解决。具体来说，transition里的move()函数在后台运行的情况下，执行的时间被延后，图片会移动得更远，currentPos会跑到正常情况不可能到达的位置，满足`currentPos <= BOUNDARY_LEFT`，因此执行了`target -= ITEMS`；然后到了stop()函数，`target - 1`是-1，于是抛出错误，下一行`on.classList.add("on")`不能执行，数字标记就从此丢失了。或者其他类似的产生bug的过程。所以，bug的直接来源是`target -= ITEMS`，这是为了连接图片带的两端而写的代码。虽然target的数值可能不准，但是以5张图片，即ITEMS的值为周期，target在某个周期内的相对值一定是准的。又因为stop()函数内部，target理论上的取值只能是1~5，结合实际情况，加上一个修正：`if (target < 1) target += ITEMS;`，就可以消除运行时间不稳定导致的问题。

在没有上一个修正的情况下，轮播只出过一次bug，是因为我打开了调试界面，此时window发生blur事件，倒计时暂停。但是在无焦点状态下，鼠标事件还是可以发生。鼠标划过页面，container发生mouseout事件，倒计时开始。这时再切换到其他浏览器窗口，因为已经没有焦点了所以不发生blur事件，于是时间线代码后台运行，出现bug。

有了修正后，似乎可以不需要避免后台运行了。但是这样确实用户不友好，而且如果考虑角度刁钻的边界条件，同时打开很多个这样的窗口，或者在特定的时刻切换窗口等等，虽然目前来说没有出过bug，但不保证不会有问题。

另一方面，鼠标事件可以在无焦点的情况下发生，这确实和我想像的不太一样。由此发现，鼠标停在轮播区域内时切换到其他进程，会先发生blur事件再发生mouseout事件，于是开始后台轮播。虽然没有安全隐患，但确实不应该是这样。因此在鼠标事件的处理器中，设定了只有在有焦点的情况下才能启动或停止计时。这样就是现在的自动轮播代码。
## 表格编辑
点击\<td\>时，将它的子节点替换为文本框。

不能用autofocus属性自动取得焦点，它只对打开页面后的第一个文本框有效。

虽然页面上同一时间只有一个文本框，但是它的CSS写在了\<style\>元素里，增加代码可读性。

文本框用innerHTML生成，光标会自动定位于文本框的最前面；用createElement()生成，光标就自动定位于文本框的最后，不知道为什么？